#requires -version 5

# Copyright 2016 Philipp Serr (episource)
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

Set-StrictMode -Version latest
$ErrorAction = "Stop"


<#
.SYNOPSIS
    Install a registry image with auto uninstallation support.
    
.DESCRIPTION
    This cmdlet wraps the Import-Registry cmdlet.adding an auto uninstall
    feature.
    
    See Import-Registry for details.

.PARAMETER Image
    The registry image to be imported (any type).
    
.PARAMETER ParentKey
    OPTIONAL - The registry is imported below the given parent key. The registry
    image must use relative paths if a parent key is specified.
    
.PARAMETER Force
    OPTIONAL - Overwrite existing values.
    
    If $Rebuild is used, $Force disables the confirmation dialog.
    
.PARAMETER Rebuild
    OPTIONAL - Each registry key contained in the image is rebuilt before
    importing its values and subkeys. THIS DELETES ALL EXISTING VALUES AND
    SUBKEYS! RECURSIVELY! USE WITH CARE!
    
.PARAMETER ForceAutoUninstall
    OPTIONAL - Peform uninstallation using the Force parameter. See
    Uninstall-RegistryImage for details.
    
.PARAMETER NoAutoUninstall
    OPTIONAL - Disable the auto uninstall feature. Uninstall-RegistryImage must
    then be added manually to chocolateyUninstall.ps1.
    
.OUTPUT
    None.

#>
function Install-RegistryImage {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [Alias("Data","KeyValuePairs")]
        [System.Collections.IDictionary] $Image,
        
        [Parameter(Mandatory=$false)] 
        [String] $ParentKey = $null,
        
        [Parameter(Mandatory=$false)]
        [Switch] $Force = $false,
        
        [Parameter(Mandatory=$false)]
        [Switch] $Rebuild = $false,
        
        [Parameter(Mandatory=$false)]
        [Switch] $ForceAutoUninstall=$false,
        
        [Parameter(Mandatory=$false)]
        [Switch] $NoAutoUninstall=$false
    )
    Process {
        Try {
            $Image = ConvertTo-FlatRegistryImage -Image $Image
            Import-Registry -Image $Image -ParentKey $ParentKey `
                -Force:$Force -Rebuild:$Rebuild
        } Catch {
            Throw
        }
            
        If (-not $NoAutoUninstall) {
            $pkgFolder       = $env:chocolateyPackageFolder
            $uninstallScript = "$pkgFolder/tools/chocolateyUninstall.ps1"
            
            $imageCode = Format-PowershellRegistryImage -Image $Image -OneLine
            $parentKeyCode = _Format-ValueAsCode $ParentKey
            $forceCode = _Format-ValueAsCode $ForceAutoUninstall
            $uninstallCmd = `
                "Uninstall-RegistryImage -ParentKey $parentKeyCode " +
                "-Force:$forceCode -Image $imageCode # autogenerated"
                
            Add-Content $uninstallScript -Value "`n$uninstallCmd"
        }
    }
}


<#
.SYNOPSIS
    Uninstalls a registry image previously installed with Install-RegistryImage.
    
.DESCRIPTION
    Uninstalls a registry image.
    
.PARAMETER Image
    The registry image to be imported (any type).
    
.PARAMETER ParentKey
    OPTIONAL - The registry is imported below the given parent key. The registry
    image must use relative paths if a parent key is specified.
    
.PARAMETER Force
    OPTIONAL - Delete values that have different values than the image.
    
.PARAMETER KeepEmptyKeys
    OPTIONAL - Don't delete keys when there are no values left.
    
.OUTPUT None
    
#>
function Uninstall-RegistryImage {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [Alias("Data","KeyValuePairs")]
        [System.Collections.IDictionary] $Image,
        
        [Parameter(Mandatory=$false)] 
        [String] $ParentKey = $null,
        
        [Parameter(Mandatory=$false)]
        [Switch] $Force = $false,
        
        [Parameter(Mandatory=$false)]
        [Alias("KeepEmptyKeys")]
        [Switch] $PreserveEmptyKeys = $false
    )
    Process {
        $flatImage = ConvertTo-FlatRegistryImage $Image
        _Uninstall-RegistryImageImpl -FlatImage $Image -ParentKey $ParentKey `
            -Force:$Force -PreserveEmptyKeys:$PreserveEmptyKeys
    }
}


<#
.SYNOPSIS
    Private implemenation of the Import-Registry cmdlet.
    
.DESCRIPTION
    See Import-Registry.
    
.PARAMETER FlatImage
    A flat registry image preprocessed with ConvertTo-FlatRegistryImage. All
    paths must be absolute if no $ParentKey is given, or relative otherwise.
    
.OUTPUT
    None.
#>
function _Uninstall-RegistryImageImpl {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true)]
        [System.Collections.IDictionary] $FlatImage,
        
        [Parameter(Mandatory=$false)] 
        [String] $ParentKey = $null,
        
        [Parameter(Mandatory=$false)]
        [Switch] $Force = $false,
        
        [Parameter(Mandatory=$false)]
        [Alias("KeepEmptyKeys")]
        [Switch] $PreserveEmptyKeys = $false
    )
    
    $defaultValue = $null
    $noExpandVars = `
        [Microsoft.Win32.RegistryValueOptions]::DoNotExpandEnvironmentNames
    
    # Use an up-to-date list of registry drives when validating registry paths.
    # => See also Test-RegistryPathValidity
    Sync-KnownRegistryDrives
    
    If ($ParentKey) {
        $imgPathType = 'Relative'
    
        $ParentKey = $ParentKey.TrimEnd('/\') + '\'
        Test-RegistryPathValidity $ParentKey -Type Absolute
    } Else {
        $imgPathType = 'Relative'
    }
    
    # Test first entry only - ConvertTo-FlatRegistryImage ensures all entries
    # use the same path type
    If ($Image.Count -gt 0) {
        $firstKey = $Image.Keys | Select-Object -First 1
        If (-not (Test-RegistryPathValidity $firstKey -Type $imgPathType)) {
            # Test-RegistryPathValidity uses Write-Error internally
            return
        }
    }
    
    $processedKeys = [System.Collections.Generic.HashSet[String]]::new()
    ForEach ($entry in $FlatImage.GetEnumerator()) {
        If ($ParentKey) {
            $path = $ParentKey + $entry.Key
        } Else {
            $path = $entry.Key
        }
        If (-not $path.Contains(":")) {
            $path = "Registry::$path"
        }
        
        $splitPathResult = Split-RegistryPath $path
        If (-not $splitPathResult) {
            # Split-RegistryPath uses Write-Error internally
            continue
        } Else {
            $keyPath = $splitPathResult.Key
            $processedKeys.Add($keyPath)
            
            # Both PowerShell and .Net API are used below: Both expect different
            # names for the default value.
            # PowerShell - $poshValueName: "(Default)"
            # .Net       - $netValueName : ""
            $poshValueName = $splitPathResult.Value
            $netValueName  = $poshValueName
            If ($netValueName -eq "(Default)") {
                $netValueName = ""
            }
        }
        
        If (-not (Test-Path $keyPath)) {
            Write-Verbose "Skipping non-existing value: $path"
        } Else {
            $skip     = $true
            $key      = Get-Item $keyPath
            $curValue = $key.GetValue( `
                $netValueName, $defaultValue, $noExpandVars)
            If ($curValue -eq $defaultValue) {
                Write-Verbose "Skipping non existing value: $path"
            } ElseIf ($Force) {
                $skip = $false
            } Else {
                $curKind = $key.GetValueKind($netValueName)
                If ($curKind -eq `
                        [Microsoft.Win32.RegistryValueKind]::ExpandString) {
                    $curValue = [ExpandString]$curValue
                }
                
                $curValueExpression = [PowershellExpression]::Get($curValue)
                $imgRegValue        = [RegistryValue]$entry.Value
                $imgValueExpression = [PowershellExpression]::Get($imgRegValue)
                
                If (($curKind -ne $imgRegValue.valueKind) `
                    -or (Compare-Object $curValue $imgRegValue.value)
                ) {
                    Write-Warning ( 
                        "Preserving modified value`n" +
                        "Expected value: $path=$imgValueExpression`n" +
                        "Actual value  : $curValueExpression")
                } Else {
                    $skip = $false
                } 
            }  
            
            If (-not $skip) {
                # Note: - Remove-ItemProperty cannot delete the default value
                #       - RegistryKey.DeleteValue requires the key to be opened with
                #         writable = $true
            
                Write-Verbose "Deleting value: $path"
                
                $parentKeyItem = Get-Item $key.PSParentPath
                $writableKey   = `
                    $parentKeyItem.OpenSubKey($key.PSChildName, $true)
                
                Try {
                    $writableKey.DeleteValue($netValueName)
                } Finally {
                    $writableKey.Close()
                }
            }
        }
    }

    If (-not $PreserveEmptyKeys) {    
        # Delete key and all parent keys if empty
        ForEach ($keyPath in $processedKeys) {
            For (
                        $curKeyPath = $keyPath;
                        $curKeyPath -and -not $curkeyPath.EndsWith(":\"); 
                        $curKeyPath = Split-Path -Parent $curKeyPath
            ) {
                If (Test-Path $curKeyPath) {
                    $curKey = Get-Item $curKeyPath
                    If ($curKey.ValueCount -eq 0 `
                            -and $curKey.SubKeyCount -eq 0) {
                        Write-Verbose "Deleting empty key: $curKey"
                        Remove-Item $curKeyPath
                    }
                }
            }
        }
    }
}


<#
.SYNOPSIS
    Install a registry image to all local user profiles' registry hives with
    auto uninstall support.
    
.DESCRIPTION
    This cmdlet wraps the Import-Registry cmdlet.adding an auto uninstall
    feature.
    
    See Import-UserRegistry for details.
    
.PARAMETER Image
    The registry image to be imported (any type).
    
.PARAMETER ParentKey
    OPTIONAL - The registry is imported below the given parent key.
    
.PARAMETER SkipDefaultProfile
    OPTIONAL - Don't import the registry image to the default user profile's
    registry hive. The default user profile's registry hive is used to
    initialize the registry of a new local user.

.PARAMETER AlsoHklm
    OPTIONAL - Also import the registry image below HKEY_LOCAL_MACHINE.

.PARAMETER Force
    OPTIONAL - Overwrite existing values.
    
    If $Rebuild is used, $Force disables the confirmation dialog.
    
.PARAMETER Rebuild
    OPTIONAL - Each registry key contained in the image is rebuilt before
    importing its values and subkeys. THIS DELETES ALL EXISTING VALUES AND
    SUBKEYS! RECURSIVELY! USE WITH CARE!
    
.PARAMETER ForceAutoUninstall
    OPTIONAL - Peform uninstallation using the Force parameter. See
    Uninstall-RegistryImage for details.
    
.PARAMETER NoAutoUninstall
    OPTIONAL - Disable the auto uninstall feature. Uninstall-RegistryImage must
    then be added manually to chocolateyUninstall.ps1.
    
.OUTPUT
    None.
  
#>
function Install-UserProfileRegistryImage {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [Alias("Data","KeyValuePairs")]
        [System.Collections.IDictionary] $Image,
        
        [Parameter(Mandatory=$false)] 
        [String] $ParentKey = $null,
        
        [Parameter(Mandatory=$false)]
        [Alias("NoDefault", "NoDefaultProfile", "SkipDefault")]
        [Switch] $SkipDefaultProfile = $false,
        
        [Parameter(Mandatory=$false)]
        [Alias("AlsoHKEY_LOCAL_MACHINE")]
        [Switch] $AlsoHklm = $false,
        
        [Parameter(Mandatory=$false)]
        [Switch] $Force = $false,
        
        [Parameter(Mandatory=$false)]
        [Switch] $Rebuild = $false,
        
        [Parameter(Mandatory=$false)]
        [Switch] $ForceAutoUninstall=$false,
        
        [Parameter(Mandatory=$false)]
        [Switch] $NoAutoUninstall=$false
    )
    Process {
        Try {
            $flatImage = ConvertTo-FlatRegistryImage -Image $Image
            _Import-UserRegistryImpl -FlatImage $flatImage `
                -ParentKey $ParentKey -SkipDefaultProfile:$SkipDefaultProfile `
                -AlsoHklm:$AlsoHklm -Force:$Force -Rebuild:$Rebuild
        } Catch {
            Throw
        }
            
        If (-not $NoAutoUninstall) {
            $pkgFolder       = $env:chocolateyPackageFolder
            $uninstallScript = "$pkgFolder/tools/chocolateyUninstall.ps1"
            
            $imageCode = Format-PowershellRegistryImage -Image $flatImage `
                -OneLine
            $parentKeyCode = _Format-ValueAsCode $ParentKey
            $skipDefaultCode = _Format-ValueAsCode $SkipDefaultProfile
            $alsoHklmCode = _Format-ValueAsCode $AlsoHklm
            $forceCode = _Format-ValueAsCode $ForceAutoUninstall
            $uninstallCmd = `
                "Uninstall-UserProfileRegistryImage " + 
                "-ParentKey $parentKeyCode " +
                "-SkipDefaultProfile:$skipDefaultCode " +
                "-AlsoHklm:$alsoHklmCode " +
                "-Force:$forceCode -Image $imageCode # autogenerated"
                
            Add-Content $uninstallScript -Value "`n$uninstallCmd"
        }
    }
}


<#
.SYNOPSIS
    Uninstalls a registry image previously installed with 
    Install-UserProfileRegistryImage.
    
.DESCRIPTION
    Uninstalls a registry image.
    
.PARAMETER Image
    The registry image to be imported (any type).
    
.PARAMETER ParentKey
    OPTIONAL - The registry is imported below the given parent key.
    
.PARAMETER SkipDefaultProfile
    OPTIONAL - Don't import the registry image to the default user profile's
    registry hive. The default user profile's registry hive is used to
    initialize the registry of a new local user.

.PARAMETER AlsoHklm
    OPTIONAL - Also import the registry image below HKEY_LOCAL_MACHINE.
    
.PARAMETER Force
    OPTIONAL - Delete values that have different values than the image.
    
.PARAMETER KeepEmptyKeys
    OPTIONAL - Don't delete keys when there are no values left.
    
.OUTPUT
    None.
    
#>
function Uninstall-UserProfileRegistryImage {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [Alias("Data","KeyValuePairs")]
        [System.Collections.IDictionary] $Image,
        
        [Parameter(Mandatory=$false)] 
        [String] $ParentKey = $null,
        
        [Parameter(Mandatory=$false)]
        [Alias("NoDefault", "NoDefaultProfile", "SkipDefault")]
        [Switch] $SkipDefaultProfile = $false,
        
        [Parameter(Mandatory=$false)]
        [Alias("AlsoHKEY_LOCAL_MACHINE")]
        [Switch] $AlsoHklm = $false,
        
        [Parameter(Mandatory=$false)]
        [Switch] $Force = $false,
        
        [Parameter(Mandatory=$false)]
        [Alias("KeepEmptyKeys")]
        [Switch] $PreserveEmptyKeys = $false
    )
    Process {
        $flatImage = ConvertTo-FlatRegistryImage $Image
        Edit-AllLocalUserProfileHives -SkipDefaultProfile:$SkipDefaultProfile `
            -AlsoHklm:$AlsoHklm -Action {
            If ($ParentKey) {
                $ParentKey = $hkuPath + '\' + $ParentKey
            } Else {
                $ParentKey = $hkuPath
            }
                
            _Uninstall-RegistryImageImpl `
                -ParentKey $ParentKey -FlatImage $flatImage `
                -Force:$Force -PreserveEmptyKeys:$PreserveEmptyKeys
        }
    }
}